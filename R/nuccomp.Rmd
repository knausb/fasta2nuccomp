---
title: "nuccomp"
author: "Insert authors here"
date: "`r format(Sys.time(), '%Y, %B %d')`"
output:
  html_document:
    toc: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.align = "center")
knitr::opts_chunk$set(fig.height = 4)
knitr::opts_chunk$set(fig.width = 4)
st1 <- Sys.time()
```


## User inputs

The user should provide the paths to the python scripts in this repository.


```{r}
# The location of nuccomp.py
my_nuccomp <- "~/gits/fasta2nuccomp/python/nuccomp.py"
# The location of motif_counter.py
my_motif_counter <- "~/gits/fasta2nuccomp/python/motif_counter.py"
```


They can also specify a window size.
Windows of 1 Mbp tend to work well for chromosomes (sequences) around 10 - 100 Mbp.
Window size is parameterizable so that investigators can explore values they feel may be appropriate.


```{r}
# window_size <- 1.5e4
# 
window_size <- 1e6
# Sort the sequences by decreasing size.
size_sort <- FALSE
#size_sort <- TRUE
# Delete files generated by nuccomp before running.
clean_files <- FALSE
#clean_files <- TRUE
```


Here we specify the FAST[AQ] format input file.
The FAST[AQ] extension, and possible gzip extension, are removed to create a base name in both python scripts.
This basename is used to create output files \*_nuccomp.csv and \*_wins.bed.
For example, the FASTA input file "GCF_900626175.2_cs10_genomic.fna.gz" will be processed into the output files "GCF_900626175.2_cs10_genomic_nuccomp.csv" and "GCF_900626175.2_cs10_genomic_CG_wins.bed", where 'CG' was the queried motif.
If these files have already been generated (e.g., the python scripts were run independently), they can be placed in the directory where this RMarkdown is compiled and they should be found by the script, avoid the need to call the python scripts.


```{r}
# Arabidopsis
# my_infile <- "GCF_000001735.4_TAIR10.1_genomic.fna.gz"
# Cottonwood
# my_infile <- "GCF_000002775.5_P.trichocarpa_v4.1_genomic.fna.gz"
# Hazelnut
# my_infile <- "GCA_901000735.2_CavTom2PMs-1.0_genomic.fna.gz"
# Hemp
# my_infile <- "GCF_900626175.2_cs10_genomic.fna.gz"
# Mint
# my_infile <- "GCA_001642375.2_Mlong_CMEN585_v3_genomic.fna.gz"
# Potato
#my_infile <- "GCF_000226075.1_SolTub_3.0_genomic.fna.gz"
# Rice
# my_infile <- "GCF_001433935.1_IRGSP-1.0_genomic.fna.gz"
# Yeast
#
my_infile <- "S288C_reference_sequence_R64-2-1_20150113.fsa.gz"
```


In order to create or predict names for output files we can omit the path information as well as common extensions.
We can then use this base name to create the output file names we expect.
This can then be used to test if the files already exist before running the script.


```{r}
my_out <- basename(my_infile)
my_out <- sub("\\.gz$", "", my_out)
my_out <- sub("\\.fa$", "", my_out)
my_out <- sub("\\.fna$", "", my_out)
my_out <- sub("\\.fsa$", "", my_out)
my_out <- sub("\\.fasta$", "", my_out)

ncomp_out <- paste(my_out, "_nuccomp.csv", sep = "")
motif_out <- paste(my_out, "_CG_wins.bed", sep = "")
```


```{r}
if( clean_files == TRUE ){
  unlink( ncomp_out )
  unlink( motif_out )
}
```


## Dependencies

From an ```R``` prompt we can query which version of ```python``` we are using.

```{r system_python}
my_python <- system("python3 -V", intern = TRUE)
my_python
```

We'll also want at least R 4.0.2.
You should see the version you have when you start R.
We'll also see how to get this information in the section 'Session information.'
You do not need RStudio, but it is recommended.


## Python scripts

### Running nuccomp.py

The python scripts in this repository may be executed at the shell or through this RMarkdown document.
Execution at the shell with the -h flag, `nuccomp.py -h`, should provide a help message.
In order to use the output in the compilation of this RMarkdown document the file should copied to the same directory as this RMarkdown file and the file name specified in the section 'Processing sequence_comp.py output'.


```{r, eval=TRUE}
st2 <- Sys.time()
# Only run python script if it's outfile does not exist. 
my_cmd <- paste("python", my_nuccomp, my_infile)
if( !file.exists( ncomp_out ) ){
  system( my_cmd )
}
st3 <- Sys.time()
st3-st2
```


This will create a comma delimited text file that has the same name as your FASTA file with the added suffix ```_nuccomp.csv```.


### Run motif_counter.py


The python script `motif_counter.py` takes as input a FASTA of FASTQ file and a motif.
The sequence in this file is divided into non-overlapping windows of user specified length.
Each window is queried for a motif using a regular expression and the count of the matches is reported.
The motif 'CG' has been selected as default because it is associated with methylation and may help identify centromeric regions.
The counts of the motif, a scaled and inverted score, and an RGB code based on the score are reported in a \*.BED format file.
This \*.BED file has embedded comments for header suggestions in R and python.


```{r}
st4 <- Sys.time()
my_cmd <- paste( "python", my_motif_counter, "--win_size", window_size, my_infile, sep = " ")
# Only run python script if it's outfile does not exist. 
if( !file.exists( motif_out ) ){
  system( my_cmd )
}
st5 <- Sys.time()
st5-st4
```

This will create a BED format text file that has the same name as your FASTA file with the added suffix that includes the motif and the *.bed extension, for example ```_CG_wins.bed```.


### Processing nuccomp.py output

Once we have summarized our FASTA data we'll want to present it.
This can be accomplished with summary statistics and graphics.
Here we demonstrate how to summarize this data.


```{r}
my_nucs <- readr::read_csv( ncomp_out )
if( size_sort == TRUE ){
  my_nucs <- my_nucs[ sort.int(my_nucs$Length, decreasing = TRUE, index.return = TRUE)$ix, ]
}
my_nucs$chrom_num <- 1:nrow(my_nucs)

if( nrow(my_nucs) > 10 ){
  max_row <- 10
} else {
  max_row <- nrow(my_nucs)
}
#knitr::kable(my_nucs[1:max_row, c(1, 2, 3:10, 23, 24)], format.args = list( big.mark = ","))
knitr::kable( my_nucs[1:max_row, ], format.args = list( big.mark = ","))
```


This FASTA file consists of `r format(sum(my_nucs$Length), big.mark=",")` nucleotides organized in `r format(length(my_nucs$Length), big.mark=",")` sequences, chromosomes or contigs.
The longest contig is `r format(max(my_nucs$Length), big.mark=",")` bp and the shortest is `r format(min(my_nucs$Length), big.mark=",")`.


#### N50


The summary statistic N50 has become a popular way to summarize the contiguity of a genome assembly.
If we sum the entire number of nucleotides in an assembly and divide this number by two we get half of the assembly size.
If we then sort the chromosomes or contigs in order of length, from longest to shortest, and walk through these until we reach the point of half of the assembly size we can report the length of the contig that contains this nucleotide.
If this contig is long we may conclude that this is a well assembled genome that approaches chromosomes.
If this contig is short we may conclude that this assembly does not approach chromosomes and may have quality issues.
In R we can calculate N50 as follows.


```{r}
my_lens <- sort(my_nucs$Length, decreasing = TRUE)
my_mid <- sum(my_lens)/2

n50 <- my_lens[cumsum(my_lens) >= my_mid][1]

format(n50, big.mark = ",")
```



### Processing results from motif_counter.py


Results from `motif_counter.py` are presented in a *.BED format file.
More information on the BED format can be found at the [UCSC BED file format FAQ](https://genome.ucsc.edu/FAQ/FAQformat.html#format1) and at Wikipedia's [BED format page](https://en.wikipedia.org/wiki/BED_(file_format)).
A BED file can be seen as tabular data that minimally includes a chromosome, start, and end coordinates.
The BED file produced by `motif_counter.py` includes 'blockCount', the motif count for the window, 'blockSizes' for each window (the last window for each sequence should be smaller than the others), and 'score' which is 1 minus the blockCount divided by blockSizes and multiplied by 1000 to range from 0 - 1000, as specified by the format.
There is also 'itemRGB' which is based on the score.
Below is an example of how to read this file into R and use the header suggestion.


```{r}

if( file.exists( motif_out ) ){
  motifs <- read.table(motif_out, sep = "\t", header = FALSE)
  my_header <- scan(motif_out, 
                    what = "character", 
                    sep = ",", skip = 1, nlines = 1)
  my_header <- sub("(^# c\\(|\\))", "", my_header)
  my_header <- sub("[[:blank:]]", "", my_header)
  colnames(motifs) <- my_header
} else {
  motifs <- structure(
    list(chrom = character(0), chromStart = integer(0), 
      chromEnd = integer(0), name = character(0), score = integer(0), 
      strand = character(0), thickStart = character(0), thickEnd = character(0), 
      itemRGB = character(0), blockCount = integer(0), blockSizes = integer(0)
      ), 
    row.names = integer(0),
    class = "data.frame")
}
#knitr::kable(motifs[1:5, ])
```


The BED file includes a 'chrom' column, which is typically a string.
For plotting purposes it's frequently convenient to have a numerical representation for each chromosome.
Here we use the order reported in the nuccomp output to assign chromosome numbers and add these to the motif_counter data.


```{r}
motifs$chrom_num <- 0
for( i in 1:nrow(my_nucs) ){
  motifs$chrom_num[ motifs$chrom == my_nucs$Id[i] ] <- my_nucs$chrom_num[i]
}
#motifs[1:3, ]
```


The BED file includes 'itemRGB' which can be converted to hexadecimal for plotting in R.


```{r}
motifs$wincol <- unlist(lapply(strsplit(motifs$itemRGB, split = ","), function(x){ rgb(red = x[1], green = x[2], blue = x[3], maxColorValue = 255) }))
knitr::kable(motifs[1:5, ])
```



## Visualization


Graphical summaries can be created in R as follows.
Note that the end user may have to adjust the manual placement of text in each plot as well as the binwidth used for the histograms.
Our hope is that this will be used as a starting point for more customized graphics.


### Sequence lengths


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )

my_max <- max(my_df$Length)
my_med <- median(my_df$Length)
my_min <- min(my_df$Length)
my_seqs <- length(my_df$Length)
my_nzero <- length(my_df$Length > 0)
my_nna <- length(!is.na(my_df$Length))
my_len <- sum(my_df$Length)

#my_denom <- 1e3
my_denom <- 1e6
my_df$Length <- my_df$Length/my_denom

my_text <- paste("Nucleotides:\n", format(my_len, big.mark = ","),
                 "\nN50: ", format(n50, big.mark = ","),
                 "\nN seqs: ", format(my_seqs, big.mark = ","),
                 "\nMax: ", format(my_max, big.mark = ","),
                 "\nMedian: ", format(my_med, big.mark = ","),
                 "\nMin: ", format(my_min, big.mark = ","),
                 sep = ""
                 )
```


```{r}
library(ggplot2)
pl <- ggplot(my_df, aes(x = Length))
#pl <- pl + geom_histogram(binwidth = 2e1, fill = "blue")
pl <- pl + geom_histogram( fill = "blue", bins = 30 )
pl <- pl + theme_bw()
pl <- pl + geom_vline(xintercept = n50/my_denom, color = "#B22222",
                      #size = 1.5,
                      linewidth = 1.5,
                      linetype="dashed")
my_ymax <- max(ggplot_build(pl)$data[[1]]$y)/2

# pl <- pl + annotate("text", x = my_max/my_denom * 0.95, y = my_ymax,
#                     label = my_text, adj = 1)

#pl <- pl + xlab("Length (Kbp)")
pl <- pl + xlab("Length (Mbp)")
pl <- pl + ylab("Count")

pl
```


Maximum value: `r format(max(my_nucs$Length), big.mark=",")`;   
median value: `r format(median(my_nucs$Length), big.mark=",")`;   
minimum value: `r format(min(my_nucs$Length), big.mark=",")`;   
length of values: `r format(length(my_nucs$Length), big.mark=",")`;   
length of values > 0: `r format(length(my_nucs$Length > 0), big.mark=",")`;   
length of values !NA: `r format(length(!is.na(my_nucs$Length)), big.mark=",")`.   


### Nucleotide composition


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("a","A")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df$Base <- "Adenine"

tmp <- as.data.frame(rowSums(my_nucs[,c("t","T")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Thymine"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("c","C")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Cytosine"
my_df <- rbind(my_df, tmp)

tmp <- as.data.frame(rowSums(my_nucs[,c("g","G")])/my_nucs$Length)
names(tmp) <- "nucs"
tmp$Base <- "Guanine"
my_df <- rbind(my_df, tmp)
my_df$Base <- factor(my_df$Base, levels = c("Adenine", "Cytosine", "Thymine", "Guanine"))

my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]
#my_df[1:3, ]

my_pal <- c("#DD0A17", "#5157FB", "#1CBE20", "#E6E431")

pat <- ggplot(my_df, aes(x = nucs, color = Base, fill = Base))
#pat <- pat + geom_histogram( binwidth = 0.01 )
pat <- pat + geom_histogram( bins = 30 )
pat <- pat + facet_wrap( . ~ Base, nrow = 2, ncol = 2)
pat <- pat + theme_bw()
pat <- pat + theme( strip.background = element_rect( fill = "#F5F5F5" ) )

#pat <- pat + xlim( c( 0, 0.5 ) )
pat <- pat + xlab("Base frequency in sequence")
pat <- pat + ylab("Sequence count")
#pat + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9", "#56B4E9"))
pat <- pat + scale_color_manual(values=c("#FFFFFF00", "#FFFFFF00", "#FFFFFF00", "#FFFFFF00"))

pat <- pat + scale_fill_manual( values = my_pal )
pat <- pat + theme(legend.position = "none")
pat
```


### IUPAC ambiguous


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df <- my_df[ !is.na(my_df$nucs), , drop = FALSE ]
my_df <- my_df[ my_df$nucs > 0, , drop = FALSE ]

pu <- ggplot(my_df, aes(x = nucs))
#pu <- pu + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pu <- pu + geom_histogram(bins=30, fill = "#AD26FA")
pu <- pu + theme_bw()
pu <- pu + xlim(c(0,1))
# pu <- pu + xlab("IUPAC ambiguous (w,W, s, S, m, M, k, K, r, R, y, Y)")
pu <- pu + xlab("IUPAC ambiguous")
pu <- pu + ylab("Count")
pu <- pu + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pu <- pu + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pu
```



```{r}
my_df <- data.frame( nucs = rowSums(my_nucs[,c("w","W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")]))
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```



The IUPAC ambiguity codes can be looked up on Wikipedia's [nucleotide](https://en.wikipedia.org/wiki/Nucleotide) page.


### Any base (N, n)


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")])/my_nucs$Length)
names(my_df) <- "nucs"
my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]
my_df <- my_df[my_df$nucs > 0, , drop = FALSE]

pn <- ggplot(my_df, aes(x = nucs))
#pn <- pn + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pn <- pn + geom_histogram(bins=30, fill = "#AD26FA")
pn <- pn + theme_bw()
pn <- pn + xlab("Any base (N,n)")
pn <- pn + ylab("Count")
pn <- pn + xlim(c(0,1))
pn <- pn + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pn <- pn + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pn
```


```{r}
my_df <- as.data.frame(rowSums(my_nucs[,c("n","N")]))
names(my_df) <- "nucs"
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```


### Unexpected characters


We generally do not expect to find anything here.
If anything is found, it probably suggests further investigation will be necessary.


```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
names(my_df) <- "nucs"
my_df$nucs <- my_df$nucs/my_nucs$Length

my_df <- my_df[!is.na(my_df$nucs), , drop = FALSE]
my_df <- my_df[my_df$nucs > 0, , drop = FALSE]
#
head(my_df)

pe <- ggplot(my_df, aes(x = nucs))
#pe <- pe + geom_histogram(binwidth=0.01, fill = "#AD26FA")
pe <- pe + geom_histogram(bins=30, fill = "#AD26FA")
pe <- pe + theme_bw()
pe <- pe + xlim(c(0,1))
#pe <- pe + xlab("Unexpected characters")
pe <- pe + xlab("Unexpected")
pe <- pe + ylab("Count")
pe <- pe + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                 axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                 )
pe <- pe + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pe
```


```{r}
my_df <- as.data.frame(
  my_nucs$Length - 
  rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
names(my_df) <- "nucs"
report <- data.frame(
  row.names = c("Maximum", "Median", "Minimum", "Number", "Number0", "Number!NA")
)
report$Value <- 0
report

if( nrow(my_df) > 0 ){
  report$Value[ 1 ] <-  max(my_df$nucs, na.rm = TRUE)
  report$Value[ 2 ] <-  median(my_df$nucs, na.rm = TRUE)
  report$Value[ 3 ] <-  min(my_df$nucs, na.rm = TRUE)
  report$Value[ 4 ] <-  length(my_df$nucs)
  report$Value[ 5 ] <-  sum(my_df$nucs > 0)
  report$Value[ 6 ] <-  length(!is.na(my_df$nucs))
}
knitr::kable(report)
```


### Length by GC


```{r}
my_df <- data.frame(Length = my_nucs$Length,
                    GC = rowSums(my_nucs[,c("c", "C", "g", "G")])
                    )
my_df$GC <- my_df$GC/my_df$Length
my_df$Length <- my_df$Length/1e6

pgc <- ggplot(my_df, aes(x = GC, y = Length))
pgc <- pgc + geom_point(size = 4, shape = 21, fill = "#B2222299")
pgc <- pgc + theme_bw()
pgc <- pgc + xlim(c(0,1))
# pgc <- pgc + ylab("Length (Kbp)")
pgc <- pgc + ylab("Mbp")
pgc <- pgc + theme(axis.title.x = element_text(size = 10, hjust = 0.5),
                   axis.text.x = element_text(angle =  0, hjust = 0.5, size=8)
                   )
pgc <- pgc + theme(axis.title.y = element_text(size = 10, hjust = 0.5))

pgc
```


We see that most sequences have a similar GC content regardless of length.
One sequence is a bit shorter than all the others and has a GC content of about a half of what the others have.
We've queried the Id above to get the accession number for this sequence.
We can then Google "NC_001224" and select the hit to NCBI and see that this sequence is the
[yeast mitochondrion](https://www.ncbi.nlm.nih.gov/nuccore/NC_001224.1).
It's been my experience that the mitochondrion will tend to have a different GC content than the nuclear sequences.


### Ideogram


Plotting of an ideogram, or cartoon, for modest numbers of sequences helps visualize the relative lengths for sequences.
For chromosome scale assemblies this may benefit from a manual step to ensure that only the chromosomes are included in the ideogram.
Other assemblies may benefit from sorting the sequences by lenght so that the longest sequences are presented.
Here we subset the sequences to the first few using an arbitrary threshold, but encourage a manual step here when possible.


```{r}
# nseq <- 10
# nseq <- 15
# nseq <- 17
# 
nseq <- 20

if( nseq > nrow(my_nucs) ){
  nseq <- nrow(my_nucs)
}

my_nucs2 <- my_nucs[1:nseq, ]
motifs <- motifs[motifs$chrom %in% my_nucs2$Id, ]
table(motifs$chrom)

```


```{r}
library(ggplot2)
chrom_wid <- 0.1

# Initialize empty plot.
p <- ggplot( )

# Add chromosomes.
p <- p + geom_rect( 
  data = my_nucs2, 
  aes( xmin = chrom_num - chrom_wid,
       xmax = chrom_num + chrom_wid,
       ymin = 1, ymax = Length),
  fill = "#DCDCDC",
  color = "#000000"
)

# Theme options.
p <- p + theme_bw()
p <- p + scale_x_continuous( 
  breaks = my_nucs2$chrom_num,
  labels = my_nucs2$Id
)
#p


if( max(my_nucs2$Length) > 1e7 ){
  yunits <- 1e7
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 10,
  )
} else if( max(my_nucs2$Length) > 1e6 ){
  yunits <- 1e6
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits,
  )
} else if( max(my_nucs2$Length) > 1e5 ){
  yunits <- 1e5
  my_ymax <- ceiling(max(my_nucs2$Length)/yunits) * yunits
  p <- p + scale_y_continuous(
    breaks = seq( 0, my_ymax, by = yunits ),
    labels = seq( 0, my_ymax, by = yunits)/yunits * 0.1,
  )
}

#p <- p + ggplot2::ylab("Position (Kbp)")
p <- p + ggplot2::ylab("Position (Mbp)")

p <- p + ggplot2::theme( 
    panel.grid.minor.x = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 ),
    axis.text.x = element_text(angle = 60, hjust = 1),
    axis.title.x=element_blank(),
    panel.grid.major.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 1 ),
    panel.grid.minor.y = ggplot2::element_line( linewidth = 0.4, color = "#C0C0C0", linetype = 3 )
  )
#p <- p + ggtitle( "My sequences" )
#p
```


```{r, fig.width=10}
p
pwin <- p
```


### Motif windows

```{r}
library(ggplot2)
#motifs[1:3, ]

if( nrow(motifs) > 0 ){
  # Add windows.
  p <- p + geom_rect( 
    data = motifs, 
    aes( xmin = chrom_num - score/1e3 * 0.4,
      xmax = chrom_num + score/1e3 * 0.4,
      ymin = chromStart, ymax = chromEnd),
    fill = motifs$wincol,
    color = motifs$wincol
#    color = "#00000055"
  )
}

```


```{r, fig.width=10}
p
pwin <- p
```


### Dashboard


For internal purposes we may want a detailed report, as presented above.
If we want to publish this information we may want to summarize this information in a single, multipanel graphic, or dashboard perspective.
This is illustrated below.


```{r, fig.height=8, fig.width=8, fig.cap="**Figure 1.** Summary of the assembly (FAST[AQ]) file. **Panel A** summarizes the distribution of sequence lengths in the assembly. **Panel B** summarizes the per sequence distribution for the rate of each nucleotide (case insensitive). **Panel C** is an ideogram (cartoon) for the first sequences where the height of each bar represents the sequence length and the with and color for windows is based on the per window inverse abundance of the 'CG' motif. **Panels D, E, and F** summarize the occurrence of IUPAC ambiguous nucleotides (wWsSmMkKrRyY), any nucelotide (nN), and any unexpected nucleotides on a per sequence/contig basis. When these panels are empty they provide positive validation that these features were searched for but not found. **Panel G** presents the relationship between the length of each sequence/contig and it's G/C content."}

library(ggpubr)

ggarrange(
  ggarrange(pl, pat,
          ncol = 2, nrow = 1,
          labels = c("A", "B"),
          widths = c(1, 1.2)
  ),
  pwin,
  ggarrange(pu, pn, pe, pgc, ncol = 4, nrow = 1, 
            labels = c("D", "E", "F", "G"),  
            font.label = list(size = 10, color = "black", face = "bold", family = NULL)),
  ncol = 1, nrow = 3,
  labels = c("", "C", ""),
  heights = c(2.0, 2.5, 1)
)


# ggsave(filename = paste(my_out, ".png", sep = ""), device = "png",
#        width = 6.5, height = 6.5, units = "in")
# ggsave(filename = paste(my_out, ".tiff", sep = ""), device = "tiff",
#        width = 6.5, height = 6.5, units = "in", compression = "lzw")
```


For the purpose of publication we may desire to save this "dashboard" as a graphic.
After the above code has been run, the ```ggsave()``` function can be uncommented and run.
You'll want to include a meaningful filename.
This will save the dashboard as a ```*.png``` or ```*.tiff``` graphic.


## Tabular output

A tabular presentation of the data may also be desirable.
Below is an example of a tabular presentation.


```{r}
genome_df <- data.frame(matrix(
  c(
    "Total length (bp)", sum(my_nucs$Length),
    "Number of sequences (count)", nrow(my_nucs),
    "N50 (bp)", n50,
    "Median length (bp)", median(my_nucs$Length),
    "Maximum length (bp)", max(my_nucs$Length),
    "Tenth longest sequence (bp)", sort(my_nucs$Length, decreasing = TRUE)[10],
    "Total A,a,C,c,G,g,T,t (bp)", sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])),
    "Total C,c,G,g (bp)", sum(colSums(my_nucs[, c("C", "c", "G", "g")])),
    "GC/ACGT (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(colSums(my_nucs[, c("A", "a", "C", "c", "G", "g", "T", "t")])) * 1e2,
    "GC/Total length (percentage)", sum(colSums(my_nucs[, c("C", "c", "G", "g")]))/sum(my_nucs$Length) * 1e2,
    "Number of Nn", sum(colSums(my_nucs[, c("N", "n")])),
    "Number of IUPAC ambiguous: wWsSmMkKrRyY", sum(colSums(my_nucs[, c("w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y")])),
    "Number of unexpected", sum(my_nucs$Length) - sum(rowSums(my_nucs[,c("a", "A", "c", "C", "g", "G", "t", "T", "w", "W", "s", "S", "m", "M", "k", "K", "r", "R", "y", "Y", "n", "N")]))
#)
  ),
  ncol = 2, byrow = TRUE
))
genome_df <- as.data.frame(genome_df)
names(genome_df) <- c("Category", "Value")
genome_df$Value <- as.numeric(genome_df$Value)
genome_df$Value <- format(genome_df$Value, 
                          digits = 3, nsmall = 3L, 
                          scientific = FALSE, big.mark = ",")

proc_time <- Sys.time() - st1
genome_df <- rbind(genome_df, c("Processing time", format( proc_time, units = "mins")))

knitr::kable(genome_df, 
             digits = 3, 
             format.args = list(scientific = FALSE, big.mark = ","),
             caption = "**Table X** Summary of the sequences.")
```


In order to use this information in other analyses it may be desirable to provide a form suitable for copy and paste operations.
This can be accomplished with modest size datasets using the command `dput()`.


```{r, comment=NA}
# 
genome_df <- t(genome_df)
colnames( genome_df ) <- genome_df[1, ]
genome_df <- genome_df[-1, , drop = FALSE]
#
dput(genome_df)
```


File output can be accomplished with the following example that outputs to comma delimited format.


```{r, comment=NA}
# write.table( x = genome_df, 
#              file = paste(my_out, "_nuccomp_summary.csv", sep = ""),
#              sep = ",",
#              row.names = FALSE, col.names = TRUE )
```



## Session information


After performing the above operations we may wish to benchmark the execution time in order to determine how feasible it is to repeat this analysis.
This has been facilitated above by taking time stamps with the function ```Sys.time()```.
We can now use these timestamps to evaluate total execution time.


```{r}
st4 <- Sys.time()
st4 - st1
```


Lastly, we can use the ```sessionInfo()``` function to report the version of ```R()``` we are using as well as the packages and their versions.
This is important information to include if we want to report an issue.


```{r}
sessionInfo()
```

